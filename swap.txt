* write tests
* streaming?
* beautify http api?

typealias CreateTimer = () -> () -> Long

object Timer {
  fun now(): Long = System.currentTimeMillis()

  fun f(): () -> Long {
    val start = now()
    return { now() - start }
  }

  val system: CreateTimer = this::f
}

inline f: invalid code




object Timer {
  fun now(): Long = System.currentTimeMillis()

    val system: CreateTimer = {
        val start = now()
        val r: () -> Long = { this.now() - start }
        r
    }
}

object Timer {
  fun now(): Long = System.currentTimeMillis()

    val system: CreateTimer = {
        val start = now()
        { this.now() - start }
    }
}

Mouse over + results in blinking hint
    fun a(): Int {
        val a = run {
            println("block1")
        }
        return a + 1
    }


//what is stack, frame lifecycle

fun foo() {
    val a = 10
    val b = "..."
    bar(b.size + a)
}

fun bar(c: Int) {
    val d = 25
    return c * d
}

//how coroutines allows to "step out" of the frame saving it's state and then resume later.
//interface Continuation<T> { //simplified for bravity
//    fun resume(value: T)
//    fun resumeWithException(exception: Throwable)
//}
//coroutines are not necessarily async!

//example generator in python
//simple generator in Kotlin without coroutines
//adding coroutines

//bonus: make it extend iterator
//bonus: make lazy tree traversal?
//bonus: talk about continuing coroutine execution with result (compiler magic!)
